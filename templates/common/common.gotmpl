{{- define "common_imports" -}}
	{{- $params := index . 0 -}}
	{{- $needStrconvForFlags := index . 1 -}}
	{{- $hasDuration := false }}
	{{- $hasStrconv := false }}
	{{- range $params }}
	{{- if or (eq .Type "time.Duration") (eq .Type "[]time.Duration") (eq .Type "*time.Duration") (eq .Type "[]*time.Duration") }}
	{{- $hasDuration = true }}
	{{- end }}
	{{- if or (eq .Type "[]time.Duration") (eq .Type "[]*time.Duration") }}
		{{- if $needStrconvForFlags }}
		{{- $hasDuration = true }}
		{{- end }}
	{{- end }}
	{{- if or (eq .Type "int") (eq .Type "bool") (eq .Type "*int") (eq .Type "*bool") (eq .Type "[]int") (eq .Type "[]bool") (eq .Type "[]*int") (eq .Type "[]*bool")
		(eq .Type "int64") (eq .Type "int32") (eq .Type "int16") (eq .Type "int8")
		(eq .Type "uint") (eq .Type "uint64") (eq .Type "uint32") (eq .Type "uint16") (eq .Type "uint8")
		(eq .Type "float64") (eq .Type "float32")
		(eq .Type "*int64") (eq .Type "*int32") (eq .Type "*int16") (eq .Type "*int8")
		(eq .Type "*uint") (eq .Type "*uint64") (eq .Type "*uint32") (eq .Type "*uint16") (eq .Type "*uint8")
		(eq .Type "*float64") (eq .Type "*float32")
		(eq .Type "[]int64") (eq .Type "[]int32") (eq .Type "[]int16") (eq .Type "[]int8")
		(eq .Type "[]uint") (eq .Type "[]uint64") (eq .Type "[]uint32") (eq .Type "[]uint16") (eq .Type "[]uint8")
		(eq .Type "[]float64") (eq .Type "[]float32")
		(eq .Type "[]*int64") (eq .Type "[]*int32") (eq .Type "[]*int16") (eq .Type "[]*int8")
		(eq .Type "[]*uint") (eq .Type "[]*uint64") (eq .Type "[]*uint32") (eq .Type "[]*uint16") (eq .Type "[]*uint8")
		(eq .Type "[]*float64") (eq .Type "[]*float32")
	}}
		{{- if or .IsPositional $needStrconvForFlags }}
		{{- $hasStrconv = true }}
		{{- end }}
	{{- end }}
	{{- end }}
	{{- if $hasStrconv }}
	"strconv"
	{{- end }}
	{{- if $hasDuration }}
	"time"
	{{- end }}
	{{- $imports := list }}
	{{- range $params }}
		{{$param := .}}
		{{- if and .ParserFunc .ParserFunc.ImportPath }}
			{{- $exists := false }}
			{{- range $i := $imports }}
				{{- if eq $i $param.ParserFunc.ImportPath }}
					{{- $exists = true }}
				{{- end }}
			{{- end }}
			{{- if not $exists }}
				{{- $imports = append $imports .ParserFunc.ImportPath }}
			{{- end }}
		{{- end }}
		{{- if and .Generator .Generator.ImportPath }}
			{{- $exists := false }}
			{{- range $i := $imports }}
				{{- if eq $i $param.Generator.ImportPath }}
					{{- $exists = true }}
				{{- end }}
			{{- end }}
			{{- if not $exists }}
				{{- $imports = append $imports .Generator.ImportPath }}
			{{- end }}
		{{- end }}
	{{- end }}
	{{- range $imports }}
	"{{.}}"
	{{- end }}
{{- end -}}

{{- define "flag_definitions" -}}
{{- $set := index . 0 -}}
{{- $struct := index . 1 -}}
{{- $params := index . 2 -}}
	{{- range $params}}
		{{- if and (not .IsPositional) (not .Generator) }}
		{{$param := .}}
		{{- $desc := .Description -}}
		{{- if not $desc }}{{ $desc = "TODO: Add usage text" }}{{ end -}}

		{{- $default := .Default -}}
		{{- if not $default -}}
			{{- if eq .Type "string" }}{{ $default = "\"\"" }}
			{{- else if eq .Type "bool" }}{{ $default = "false" }}
			{{- else if eq .Type "time.Duration" }}{{ $default = "0" }}
			{{- else if eq .Type "[]string" }}{{ $default = "nil" }}
			{{- else if or (eq .Type "int") (eq .Type "int64") (eq .Type "int32") (eq .Type "int16") (eq .Type "int8") (eq .Type "uint") (eq .Type "uint64") (eq .Type "uint32") (eq .Type "uint16") (eq .Type "uint8") (eq .Type "float64") (eq .Type "float32") }}{{ $default = "0" }}{{ end -}}
		{{- else -}}
			{{- if eq .Type "string" }}{{ $default = printf "%q" .Default }}
			{{- else }}{{ $default = .Default }}{{ end -}}
		{{- end -}}

		{{- $typeTitle := $param.Type | title -}}
		{{- if eq $param.Type "time.Duration" -}}
			{{- $typeTitle = "Duration" -}}
		{{- end -}}

		{{- $aliases := .FlagAliases }}
		{{- if not $aliases }}{{ $aliases = list .Name }}{{ end }}

		{{- range $aliases }}
			{{- if $param.IsSlice }}
				{{- $baseName := $param.BaseType | title }}
				{{- if $param.IsDuration }}{{ $baseName = "Duration" }}{{ end }}
				{{- $helperName := printf "%sSlice" $baseName }}
				{{- if $param.HasPointer }}{{ $helperName = printf "%sPointerSlice" $baseName }}{{ end }}
	{{$set}}.Var((*{{$helperName}})(&{{$struct}}.{{$param.Name}}), "{{.}}", "{{$desc}}")
			{{- else }}
				{{- if $param.ParserFunc }}
	{{$set}}.Func("{{.}}", "{{$desc}}", func(s string) error {
		v, err := {{$param.ParserCall "s"}}
		if err != nil {
			return err
		}
		val := {{$param.CastCode "v"}}
		{{- if $param.HasPointer }}
		{{$struct}}.{{$param.Name}} = &val
		{{- else }}
		{{$struct}}.{{$param.Name}} = val
		{{- end }}
		return nil
	})
				{{- else if $param.HasPointer }}
					{{- if $param.IsString }}
	{{$set}}.Func("{{.}}", "{{$desc}}", func(s string) error {
		{{$struct}}.{{$param.Name}} = &s
		return nil
	})
					{{- else }}
						{{- $funcName := "Func" }}
						{{- if $param.IsBool }}{{ $funcName = "BoolFunc" }}{{ end }}
	{{$set}}.{{$funcName}}("{{.}}", "{{$desc}}", func(s string) error {
		v, err := {{$param.ParserCall "s"}}
		if err != nil {
			return err
		}
		val := {{$param.CastCode "v"}}
		{{$struct}}.{{$param.Name}} = &val
		return nil
	})
					{{- end }}
				{{- else }}
					{{- if $param.IsDuration }}
	if d, err := time.ParseDuration("{{$default}}"); err == nil {
		{{$set}}.DurationVar(&{{$struct}}.{{$param.Name}}, "{{.}}", d, "{{$desc}}")
	} else {
		{{$set}}.DurationVar(&{{$struct}}.{{$param.Name}}, "{{.}}", 0, "{{$desc}}")
	}
					{{- else if or (eq $param.BaseType "int") (eq $param.BaseType "string") (eq $param.BaseType "bool") (eq $param.BaseType "uint") (eq $param.BaseType "uint64") (eq $param.BaseType "int64") (eq $param.BaseType "float64") }}
						{{- $varType := $param.BaseType | title }}
	{{$set}}.{{$varType}}Var(&{{$struct}}.{{$param.Name}}, "{{.}}", {{$default}}, "{{$desc}}")
					{{- else }}
	{{$set}}.Func("{{.}}", "{{$desc}}", func(s string) error {
		v, err := {{$param.ParserCall "s"}}
		if err != nil {
			return err
		}
		{{$struct}}.{{$param.Name}} = {{$param.CastCode "v"}}
		return nil
	})
					{{- end }}
				{{- end }}
			{{- end }}
		{{- end }}
		{{- end }}
	{{- end}}
{{- end -}}

{{- define "positional_args_parsing" -}}
{{- $params := . -}}
{{- $posArgs := 0 }}
	{{- range $params }}
		{{- if .IsPositional }}
			{{- if not .IsVarArg }}
				{{- $posArgs = add $posArgs 1 }}
			{{- end }}
		{{- end }}
	{{- end }}

	{{- if gt $posArgs 0 }}
	if len(remainingArgs) < {{$posArgs}} {
		return fmt.Errorf("expected at least {{$posArgs}} positional arguments, got %d", len(remainingArgs))
	}
	{{- end }}

	{{- range $params }}
		{{- if .IsPositional }}
			{{- if .IsVarArg }}
	// Handle vararg {{.Name}}
	{
		varArgStart := {{if .PositionalArgIndex}}{{.PositionalArgIndex | add -1}}{{else}}{{$posArgs}}{{end}}
		if varArgStart > len(remainingArgs) {
			varArgStart = len(remainingArgs)
		}
		varArgs := remainingArgs[varArgStart:]
		{{- if gt .VarArgMin 0}}
		if len(varArgs) < {{.VarArgMin}} {
			return fmt.Errorf("expected at least {{.VarArgMin}} arguments for {{.Name}}, got %d", len(varArgs))
		}
		{{- end }}
		{{- if gt .VarArgMax 0}}
		if len(varArgs) > {{.VarArgMax}} {
			return fmt.Errorf("expected at most {{.VarArgMax}} arguments for {{.Name}}, got %d", len(varArgs))
		}
		{{- end }}
		{{- if .IsString }}
		c.{{.Name}} = varArgs
		{{- else }}
		for _, arg := range varArgs {
			v, err := {{.ParserCall "arg"}}
			if err != nil {
				return fmt.Errorf("invalid {{.TypeDescription}} argument for {{.Name}}: %s", arg)
			}
			c.{{.Name}} = append(c.{{.Name}}, {{.CastCode "v"}})
		}
		{{- end }}
	}
			{{- else }}
	// Handle positional argument {{.Name}}
	{
		argIndex := {{.PositionalArgIndex | add -1}}
		if argIndex >= 0 && argIndex < len(remainingArgs) {
			argVal := remainingArgs[argIndex]
			{{- if .IsString }}
			c.{{.Name}} = argVal
			{{- else }}
			v, err := {{.ParserCall "argVal"}}
			if err != nil {
				return fmt.Errorf("invalid {{.TypeDescription}} argument for {{.Name}} at index %d: %s", argIndex, argVal)
			}
			c.{{.Name}} = {{.CastCode "v"}}
			{{- end }}
		}
	}
			{{- end }}
		{{- end }}
	{{- end }}
{{- end -}}

{{- define "flag_helper_types" -}}
type StringSlice []string

func (s *StringSlice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("[%s]", strings.Join(*s, ", "))
}

func (s *StringSlice) Set(value string) error {
	*s = append(*s, value)
	return nil
}

type IntSlice []int

func (s *IntSlice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *IntSlice) Set(value string) error {
	i, err := strconv.Atoi(value)
	if err != nil {
		return err
	}
	*s = append(*s, i)
	return nil
}

type Int64Slice []int64

func (s *Int64Slice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *Int64Slice) Set(value string) error {
	i, err := strconv.ParseInt(value, 10, 64)
	if err != nil {
		return err
	}
	*s = append(*s, i)
	return nil
}

type Int32Slice []int32

func (s *Int32Slice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *Int32Slice) Set(value string) error {
	i, err := strconv.ParseInt(value, 10, 32)
	if err != nil {
		return err
	}
	*s = append(*s, int32(i))
	return nil
}

type Int16Slice []int16

func (s *Int16Slice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *Int16Slice) Set(value string) error {
	i, err := strconv.ParseInt(value, 10, 16)
	if err != nil {
		return err
	}
	*s = append(*s, int16(i))
	return nil
}

type Int8Slice []int8

func (s *Int8Slice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *Int8Slice) Set(value string) error {
	i, err := strconv.ParseInt(value, 10, 8)
	if err != nil {
		return err
	}
	*s = append(*s, int8(i))
	return nil
}

type UintSlice []uint

func (s *UintSlice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *UintSlice) Set(value string) error {
	i, err := strconv.ParseUint(value, 10, 64) // uint can be 32 or 64 bit, but 64 covers both
	if err != nil {
		return err
	}
	*s = append(*s, uint(i))
	return nil
}

type Uint64Slice []uint64

func (s *Uint64Slice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *Uint64Slice) Set(value string) error {
	i, err := strconv.ParseUint(value, 10, 64)
	if err != nil {
		return err
	}
	*s = append(*s, i)
	return nil
}

type Uint32Slice []uint32

func (s *Uint32Slice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *Uint32Slice) Set(value string) error {
	i, err := strconv.ParseUint(value, 10, 32)
	if err != nil {
		return err
	}
	*s = append(*s, uint32(i))
	return nil
}

type Uint16Slice []uint16

func (s *Uint16Slice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *Uint16Slice) Set(value string) error {
	i, err := strconv.ParseUint(value, 10, 16)
	if err != nil {
		return err
	}
	*s = append(*s, uint16(i))
	return nil
}

type Uint8Slice []uint8

func (s *Uint8Slice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *Uint8Slice) Set(value string) error {
	i, err := strconv.ParseUint(value, 10, 8)
	if err != nil {
		return err
	}
	*s = append(*s, uint8(i))
	return nil
}

type Float64Slice []float64

func (s *Float64Slice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *Float64Slice) Set(value string) error {
	f, err := strconv.ParseFloat(value, 64)
	if err != nil {
		return err
	}
	*s = append(*s, f)
	return nil
}

type Float32Slice []float32

func (s *Float32Slice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *Float32Slice) Set(value string) error {
	f, err := strconv.ParseFloat(value, 32)
	if err != nil {
		return err
	}
	*s = append(*s, float32(f))
	return nil
}

type BoolSlice []bool

func (s *BoolSlice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *BoolSlice) Set(value string) error {
	b, err := strconv.ParseBool(value)
	if err != nil {
		return err
	}
	*s = append(*s, b)
	return nil
}

func (s *BoolSlice) IsBoolFlag() bool {
	return true
}

type DurationSlice []time.Duration

func (s *DurationSlice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *DurationSlice) Set(value string) error {
	d, err := time.ParseDuration(value)
	if err != nil {
		return err
	}
	*s = append(*s, d)
	return nil
}

type StringPointerSlice []*string

func (s *StringPointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, *p)
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *StringPointerSlice) Set(value string) error {
	val := value
	*s = append(*s, &val)
	return nil
}

type IntPointerSlice []*int

func (s *IntPointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%d", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *IntPointerSlice) Set(value string) error {
	i, err := strconv.Atoi(value)
	if err != nil {
		return err
	}
	*s = append(*s, &i)
	return nil
}

type Int64PointerSlice []*int64

func (s *Int64PointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%d", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *Int64PointerSlice) Set(value string) error {
	i, err := strconv.ParseInt(value, 10, 64)
	if err != nil {
		return err
	}
	*s = append(*s, &i)
	return nil
}

type Int32PointerSlice []*int32

func (s *Int32PointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%d", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *Int32PointerSlice) Set(value string) error {
	i, err := strconv.ParseInt(value, 10, 32)
	if err != nil {
		return err
	}
	v := int32(i)
	*s = append(*s, &v)
	return nil
}

type Int16PointerSlice []*int16

func (s *Int16PointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%d", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *Int16PointerSlice) Set(value string) error {
	i, err := strconv.ParseInt(value, 10, 16)
	if err != nil {
		return err
	}
	v := int16(i)
	*s = append(*s, &v)
	return nil
}

type Int8PointerSlice []*int8

func (s *Int8PointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%d", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *Int8PointerSlice) Set(value string) error {
	i, err := strconv.ParseInt(value, 10, 8)
	if err != nil {
		return err
	}
	v := int8(i)
	*s = append(*s, &v)
	return nil
}

type UintPointerSlice []*uint

func (s *UintPointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%d", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *UintPointerSlice) Set(value string) error {
	i, err := strconv.ParseUint(value, 10, 64)
	if err != nil {
		return err
	}
	v := uint(i)
	*s = append(*s, &v)
	return nil
}

type Uint64PointerSlice []*uint64

func (s *Uint64PointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%d", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *Uint64PointerSlice) Set(value string) error {
	i, err := strconv.ParseUint(value, 10, 64)
	if err != nil {
		return err
	}
	*s = append(*s, &i)
	return nil
}

type Uint32PointerSlice []*uint32

func (s *Uint32PointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%d", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *Uint32PointerSlice) Set(value string) error {
	i, err := strconv.ParseUint(value, 10, 32)
	if err != nil {
		return err
	}
	v := uint32(i)
	*s = append(*s, &v)
	return nil
}

type Uint16PointerSlice []*uint16

func (s *Uint16PointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%d", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *Uint16PointerSlice) Set(value string) error {
	i, err := strconv.ParseUint(value, 10, 16)
	if err != nil {
		return err
	}
	v := uint16(i)
	*s = append(*s, &v)
	return nil
}

type Uint8PointerSlice []*uint8

func (s *Uint8PointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%d", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *Uint8PointerSlice) Set(value string) error {
	i, err := strconv.ParseUint(value, 10, 8)
	if err != nil {
		return err
	}
	v := uint8(i)
	*s = append(*s, &v)
	return nil
}

type Float64PointerSlice []*float64

func (s *Float64PointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%v", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *Float64PointerSlice) Set(value string) error {
	f, err := strconv.ParseFloat(value, 64)
	if err != nil {
		return err
	}
	*s = append(*s, &f)
	return nil
}

type Float32PointerSlice []*float32

func (s *Float32PointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%v", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *Float32PointerSlice) Set(value string) error {
	f, err := strconv.ParseFloat(value, 32)
	if err != nil {
		return err
	}
	v := float32(f)
	*s = append(*s, &v)
	return nil
}

type BoolPointerSlice []*bool

func (s *BoolPointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%v", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *BoolPointerSlice) Set(value string) error {
	b, err := strconv.ParseBool(value)
	if err != nil {
		return err
	}
	*s = append(*s, &b)
	return nil
}

func (s *BoolPointerSlice) IsBoolFlag() bool {
	return true
}

type DurationPointerSlice []*time.Duration

func (s *DurationPointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%v", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *DurationPointerSlice) Set(value string) error {
	d, err := time.ParseDuration(value)
	if err != nil {
		return err
	}
	*s = append(*s, &d)
	return nil
}
{{- end -}}
