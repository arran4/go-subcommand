{{/*
	Common helper templates for code generation.
*/}}

{{- define "common_imports" -}}
{{- $params := index . 0 -}}
{{- $isRoot := index . 1 -}}
	{{- $imports := list }}
	{{- range $params }}
		{{$param := .}}
		{{- if and (eq .Parser.Type "custom") .Parser.Func .Parser.Func.ImportPath }}
			{{- $exists := false }}
			{{- range $i := $imports }}
				{{- if eq $i $param.Parser.Func.ImportPath }}
					{{- $exists = true }}
				{{- end }}
			{{- end }}
			{{- if not $exists }}
				{{- $imports = append $imports .Parser.Func.ImportPath }}
			{{- end }}
		{{- end }}
		{{- if and (eq .Generator.Type "generator") .Generator.Func .Generator.Func.ImportPath }}
			{{- $exists := false }}
			{{- range $i := $imports }}
				{{- if eq $i $param.Generator.Func.ImportPath }}
					{{- $exists = true }}
				{{- end }}
			{{- end }}
			{{- if not $exists }}
				{{- $imports = append $imports .Generator.Func.ImportPath }}
			{{- end }}
		{{- end }}
	{{- end }}
	{{- if gt (len $imports) 0 }}
	{{- range $imports }}
	"{{.}}"
	{{- end }}
	{{- end }}
	"strconv"
	"time"
{{- end -}}

{{- define "flag_definitions" -}}
{{- $set := index . 0 -}}
{{- $struct := index . 1 -}}
{{- $params := index . 2 -}}
	{{- range $params}}
		{{- if and (not .IsPositional) (eq .Generator.Type "flag") }}
		{{$param := .}}
		{{- $desc := .Description -}}
		{{- if not $desc }}{{ $desc = "TODO: Add usage text" }}{{ end -}}
		{{- $aliases := .FlagAliases -}}
		{{- $baseName := .Name -}}
		{{- range $aliases}}
			{{- if $param.IsBool }}
				{{- if $param.IsSlice }}
					{{- $helperName := "BoolSlice" }}
					{{- if $param.HasPointer }}{{ $helperName = "BoolPointerSlice" }}{{ end }}
	{{$set}}.Var((*{{$helperName}})(&{{$struct}}.{{$param.Name}}), "{{.}}", "{{$desc}}")
				{{- else }}
					{{- if $param.HasPointer }}
	{{$set}}.BoolVar({{$struct}}.{{$param.Name}}, "{{.}}", false, "{{$desc}}") // Pointer handled in Execute
					{{- else }}
	{{$set}}.BoolVar(&{{$struct}}.{{$param.Name}}, "{{.}}", {{if $param.Default}}{{$param.Default}}{{else}}false{{end}}, "{{$desc}}")
					{{- end }}
				{{- end }}
			{{- else if $param.IsString }}
				{{- if $param.IsSlice }}
					{{- $helperName := "StringSlice" }}
					{{- if $param.HasPointer }}{{ $helperName = "StringPointerSlice" }}{{ end }}
	{{$set}}.Var((*{{$helperName}})(&{{$struct}}.{{$param.Name}}), "{{.}}", "{{$desc}}")
				{{- else }}
					{{- if $param.HasPointer }}
	{{$set}}.StringVar({{$struct}}.{{$param.Name}}, "{{.}}", "{{if $param.Default}}{{$param.Default}}{{end}}", "{{$desc}}")
					{{- else }}
	{{$set}}.StringVar(&{{$struct}}.{{$param.Name}}, "{{.}}", "{{if $param.Default}}{{$param.Default}}{{end}}", "{{$desc}}")
					{{- end }}
				{{- end }}
			{{- else }}
				{{- if $param.IsSlice }}
					{{- $baseType := $param.BaseType | title }}
					{{- if hasPrefix $param.BaseType "int" }}{{ $baseType = "Int" }}{{ end }}
					{{- if hasPrefix $param.BaseType "uint" }}{{ $baseType = "Uint" }}{{ end }}
					{{- if hasPrefix $param.BaseType "float" }}{{ $baseType = "Float" }}{{ end }}
					{{- if eq $param.BaseType "time.Duration" }}{{ $baseType = "Duration" }}{{ end }}
					{{- $helperName := printf "%sSlice" $baseType }}
					{{- if $param.BaseType | hasPrefix "int" }}
						{{- if ne $param.BaseType "int" }}{{ $helperName = printf "%sSlice" ($param.BaseType | title) }}{{ end }}
					{{- end }}
					{{- if $param.BaseType | hasPrefix "uint" }}
						{{- if ne $param.BaseType "uint" }}{{ $helperName = printf "%sSlice" ($param.BaseType | title) }}{{ end }}
					{{- end }}
					{{- if $param.BaseType | hasPrefix "float" }}
						{{- if ne $param.BaseType "float" }}{{ $helperName = printf "%sSlice" ($param.BaseType | title) }}{{ end }}
					{{- end }}
					{{- if $param.HasPointer }}{{ $helperName = printf "%sPointerSlice" $baseName }}{{ end }}
	{{$set}}.Var((*{{$helperName}})(&{{$struct}}.{{$param.Name}}), "{{.}}", "{{$desc}}")
			{{- else }}
				{{- if eq $param.Parser.Type "custom" }}
	{{$set}}.Func("{{.}}", "{{$desc}}", func(s string) error {
		v, err := {{$param.ParserCall "s"}}
		if err != nil {
			return err
		}
		val := {{$param.CastCode "v"}}
		{{- if $param.HasPointer }}
		{{$struct}}.{{$param.Name}} = &val
		{{- else }}
		{{$struct}}.{{$param.Name}} = val
		{{- end }}
		return nil
	})
				{{- else }}
					{{- if eq $param.BaseType "int" }}
						{{- if $param.HasPointer }}
	{{$set}}.Var((*IntPointer)({{$struct}}.{{$param.Name}}), "{{.}}", "{{$desc}}")
						{{- else }}
	{{$set}}.IntVar(&{{$struct}}.{{$param.Name}}, "{{.}}", {{if $param.Default}}{{$param.Default}}{{else}}0{{end}}, "{{$desc}}")
						{{- end }}
					{{- else if eq $param.BaseType "int64" }}
						{{- if $param.HasPointer }}
	{{$set}}.Var((*Int64Pointer)({{$struct}}.{{$param.Name}}), "{{.}}", "{{$desc}}")
						{{- else }}
	{{$set}}.Int64Var(&{{$struct}}.{{$param.Name}}, "{{.}}", {{if $param.Default}}{{$param.Default}}{{else}}0{{end}}, "{{$desc}}")
						{{- end }}
					{{- else if eq $param.BaseType "uint" }}
						{{- if $param.HasPointer }}
	{{$set}}.Var((*UintPointer)({{$struct}}.{{$param.Name}}), "{{.}}", "{{$desc}}")
						{{- else }}
	{{$set}}.UintVar(&{{$struct}}.{{$param.Name}}, "{{.}}", {{if $param.Default}}{{$param.Default}}{{else}}0{{end}}, "{{$desc}}")
						{{- end }}
					{{- else if eq $param.BaseType "uint64" }}
						{{- if $param.HasPointer }}
	{{$set}}.Var((*Uint64Pointer)({{$struct}}.{{$param.Name}}), "{{.}}", "{{$desc}}")
						{{- else }}
	{{$set}}.Uint64Var(&{{$struct}}.{{$param.Name}}, "{{.}}", {{if $param.Default}}{{$param.Default}}{{else}}0{{end}}, "{{$desc}}")
						{{- end }}
					{{- else if eq $param.BaseType "float64" }}
						{{- if $param.HasPointer }}
	{{$set}}.Var((*Float64Pointer)({{$struct}}.{{$param.Name}}), "{{.}}", "{{$desc}}")
						{{- else }}
	{{$set}}.Float64Var(&{{$struct}}.{{$param.Name}}, "{{.}}", {{if $param.Default}}{{$param.Default}}{{else}}0.0{{end}}, "{{$desc}}")
						{{- end }}
					{{- else if eq $param.BaseType "time.Duration" }}
						{{- if $param.HasPointer }}
	{{$set}}.Var((*DurationPointer)({{$struct}}.{{$param.Name}}), "{{.}}", "{{$desc}}")
						{{- else }}
	{{$set}}.DurationVar(&{{$struct}}.{{$param.Name}}, "{{.}}", {{if $param.Default}}{{$param.Default}}{{else}}0{{end}}, "{{$desc}}")
						{{- end }}
					{{- else }}
	{{$set}}.Func("{{.}}", "{{$desc}}", func(s string) error {
		v, err := {{$param.ParserCall "s"}}
		if err != nil {
			return err
		}
		val := {{$param.CastCode "v"}}
		{{- if $param.HasPointer }}
		{{$struct}}.{{$param.Name}} = &val
		{{- else }}
		{{$struct}}.{{$param.Name}} = val
		{{- end }}
		return nil
	})
					{{- end }}
				{{- end }}
			{{- end }}
		{{- end }}
		{{- end }}
	{{- end}}
{{- end -}}

{{- define "positional_args_parsing" -}}
	{{- $params := . -}}
	{{- $posParams := list }}
	{{- range $params }}
		{{- if .IsPositional }}
			{{- $posParams = append $posParams . }}
		{{- end }}
	{{- end }}
	{{- if gt (len $posParams) 0 }}
	// Positional arguments parsing
	posArgs := remainingArgs
	{{- range $i, $p := $posParams }}
		{{- if $p.IsVarArg }}
		// Variadic argument: {{$p.Name}}
		for _, arg := range posArgs[{{$i}}:] {
			{{- if $p.IsString }}
			c.{{$p.Name}} = append(c.{{$p.Name}}, arg)
			{{- else }}
			v, err := {{$p.ParserCall "arg"}}
			if err != nil {
				return fmt.Errorf("invalid value for argument {{$p.Name}}: %w", err)
			}
			c.{{$p.Name}} = append(c.{{$p.Name}}, {{$p.CastCode "v"}})
			{{- end }}
		}
		{{- else }}
		// Argument: {{$p.Name}}
		if len(posArgs) > {{$i}} {
			{{- if $p.IsString }}
			c.{{$p.Name}} = posArgs[{{$i}}]
			{{- else }}
			v, err := {{$p.ParserCall "posArgs["}}{{ $i }}{{"]"}}
			if err != nil {
				return fmt.Errorf("invalid value for argument {{$p.Name}}: %w", err)
			}
			c.{{$p.Name}} = {{$p.CastCode "v"}}
			{{- end }}
		} {{ if $p.IsRequired }} else {
			return fmt.Errorf("missing required argument: {{$p.Name}}")
		} {{- end }}
		{{- end }}
	{{- end }}
	{{- end }}
{{- end -}}
