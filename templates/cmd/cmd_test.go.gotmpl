// Code generated by github.com/arran4/go-subcommand/cmd/gosubc. DO NOT EDIT.

package main

import (
	"flag"
	"testing"
	{{- $hasDuration := false }}
	{{- range .Parameters}}
	{{- if eq .Type "time.Duration" }}
	{{- $hasDuration = true }}
	{{- end }}
	{{- end }}
	{{- if $hasDuration }}
	"time"
	{{- end }}
)

func Test{{.SubCommandStructName}}_Execute(t *testing.T) {
	{{if .Parent}}
	parent := &{{.Parent.SubCommandStructName}}{}
	cmd := parent.New{{.SubCommandStructName}}()
	{{else}}
	parent := &RootCmd{
		FlagSet: flag.NewFlagSet("root", flag.ContinueOnError),
		Commands: make(map[string]Cmd),
	}
	cmd := parent.New{{.SubCommandStructName}}()
	{{end}}

	called := false
	cmd.CommandAction = func(c *{{.SubCommandStructName}}) error {
		called = true
		return nil
	}

	args := []string{}
	{{- range .Parameters}}
	{{- $param := . }}
	{{- if .IsPositional}}
		{{- if .IsVarArg}}
			{{- if gt .VarArgMin 0}}
				{{- range until .VarArgMin}}
					{{- if eq $param.Type "string"}}
					args = append(args, "test")
					{{- else if eq $param.Type "int"}}
					args = append(args, "1")
					{{- else if eq $param.Type "bool"}}
					args = append(args, "true")
					{{- else if eq $param.Type "time.Duration"}}
					args = append(args, "1s")
					{{- end}}
				{{- end}}
			{{- end}}
		{{- else}}
			{{- if eq .Type "string"}}
			args = append(args, "test")
			{{- else if eq .Type "int"}}
			args = append(args, "1")
			{{- else if eq .Type "bool"}}
			args = append(args, "true")
			{{- else if eq .Type "time.Duration"}}
			args = append(args, "1s")
			{{- end}}
		{{- end}}
	{{- else}}
		args = append(args, "--{{.Name}}")
		{{- if ne .Type "bool"}}
			{{- if eq .Type "string"}}
			args = append(args, "test")
			{{- else if eq .Type "int"}}
			args = append(args, "1")
			{{- else if eq .Type "time.Duration"}}
			args = append(args, "1s")
			{{- end}}
		{{- end}}
	{{- end}}
	{{- end}}

	err := cmd.Execute(args)
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}
	if !called {
		t.Error("CommandAction was not called")
	}

	{{range .Parameters}}
	{{- $param := . }}
	{{- if .IsPositional}}
		{{- if .IsVarArg}}
			{{- if gt .VarArgMin 0}}
				if len(cmd.{{.Name}}) != {{.VarArgMin}} {
					t.Errorf("Expected {{.Name}} to have length {{.VarArgMin}}, got %d", len(cmd.{{.Name}}))
				}
				{{- range $i := until .VarArgMin}}
					{{- if eq $param.Type "string"}}
					if cmd.{{$param.Name}}[{{$i}}] != "test" {
						t.Errorf("Expected {{$param.Name}}[%d] to be 'test', got '%v'", {{$i}}, cmd.{{$param.Name}}[{{$i}}])
					}
					{{- else if eq $param.Type "int"}}
					if cmd.{{$param.Name}}[{{$i}}] != 1 {
						t.Errorf("Expected {{$param.Name}}[%d] to be 1, got '%v'", {{$i}}, cmd.{{$param.Name}}[{{$i}}])
					}
					{{- end}}
				{{- end}}
			{{- end}}
		{{- else}}
			{{- if eq .Type "string"}}
			if cmd.{{.Name}} != "test" {
				t.Errorf("Expected {{.Name}} to be 'test', got '%v'", cmd.{{.Name}})
			}
			{{- else if eq .Type "int"}}
			if cmd.{{.Name}} != 1 {
				t.Errorf("Expected {{.Name}} to be 1, got '%v'", cmd.{{.Name}})
			}
			{{- else if eq .Type "bool"}}
			if cmd.{{.Name}} != true {
				t.Errorf("Expected {{.Name}} to be true, got '%v'", cmd.{{.Name}})
			}
			{{- else if eq .Type "time.Duration"}}
			if cmd.{{.Name}} != 1 * time.Second {
				t.Errorf("Expected {{.Name}} to be 1s, got '%v'", cmd.{{.Name}})
			}
			{{- end}}
		{{- end}}
	{{- else}}
		{{- if eq .Type "string"}}
		if cmd.{{.Name}} != "test" {
			t.Errorf("Expected {{.Name}} to be 'test', got '%v'", cmd.{{.Name}})
		}
		{{- else if eq .Type "int"}}
		if cmd.{{.Name}} != 1 {
			t.Errorf("Expected {{.Name}} to be 1, got '%v'", cmd.{{.Name}})
		}
		{{- else if eq .Type "bool"}}
		if cmd.{{.Name}} != true {
			t.Errorf("Expected {{.Name}} to be true, got '%v'", cmd.{{.Name}})
		}
		{{- else if eq .Type "time.Duration"}}
		if cmd.{{.Name}} != 1 * time.Second {
			t.Errorf("Expected {{.Name}} to be 1s, got '%v'", cmd.{{.Name}})
		}
		{{- end}}
	{{- end}}
	{{- end}}
}

{{- $shortBools := slice }}
{{- $shortValFlag := "" }}
{{- $shortValType := "" }}
{{- $hasShortValFlag := false }}

{{- range .Parameters }}
    {{- if not .IsPositional }}
        {{- $param := . }}
        {{- $shortName := "" }}
        {{- if eq (len $param.Name) 1 }}
            {{- $shortName = $param.Name }}
        {{- else }}
            {{- range $param.FlagAliases }}
                {{- if eq (len .) 1 }}
                    {{- $shortName = . }}
                {{- end }}
            {{- end }}
        {{- end }}

        {{- if ne $shortName "" }}
            {{- if eq $param.Type "bool" }}
                {{- $shortBools = append $shortBools $param }}
            {{- else if eq $param.Type "string" }}
                {{- $shortValFlag = $param }}
                {{- $shortValType = "string" }}
                {{- $hasShortValFlag = true }}
            {{- else if eq $param.Type "int" }}
                {{- $shortValFlag = $param }}
                {{- $shortValType = "int" }}
                {{- $hasShortValFlag = true }}
            {{- end }}
        {{- end }}
    {{- end }}
{{- end }}

{{- if or (ge (len $shortBools) 2) (and (ge (len $shortBools) 1) $hasShortValFlag) }}
func Test{{.SubCommandStructName}}_Execute_Bundling(t *testing.T) {
	{{if .Parent}}
	parent := &{{.Parent.SubCommandStructName}}{}
	cmd := parent.New{{.SubCommandStructName}}()
	{{else}}
	parent := &RootCmd{
		FlagSet: flag.NewFlagSet("root", flag.ContinueOnError),
		Commands: make(map[string]Cmd),
	}
	cmd := parent.New{{.SubCommandStructName}}()
	{{end}}

    // Construct bundle argument
    bundle := "-"

    {{- range $shortBools }}
        // Find short name again
        {{- $sName := "" }}
        {{- if eq (len .Name) 1 }}{{ $sName = .Name }}{{ else }}{{ range .FlagAliases }}{{ if eq (len .) 1 }}{{ $sName = . }}{{ end }}{{ end }}{{ end }}
        bundle += "{{$sName}}"
    {{- end }}

    {{- if $hasShortValFlag }}
        {{- $sName := "" }}
        {{- with $shortValFlag }}
             {{- if eq (len .Name) 1 }}{{ $sName = .Name }}{{ else }}{{ range .FlagAliases }}{{ if eq (len .) 1 }}{{ $sName = . }}{{ end }}{{ end }}{{ end }}
        {{- end }}
        bundle += "{{$sName}}"
        {{- if eq $shortValType "string" }}
        bundle += "test"
        {{- else if eq $shortValType "int" }}
        bundle += "1"
        {{- end }}
    {{- end }}

	called := false
	cmd.CommandAction = func(c *{{.SubCommandStructName}}) error {
		called = true
		return nil
	}

    args := []string{bundle}
    {{- range .Parameters }}
	{{- $param := . }}
    {{- if .IsPositional }}
        {{- if .IsVarArg }}
            {{- if gt .VarArgMin 0}}
				{{- range until .VarArgMin}}
					{{- if eq $param.Type "string"}}
					args = append(args, "test")
					{{- else if eq $param.Type "int"}}
					args = append(args, "1")
					{{- else if eq $param.Type "bool"}}
					args = append(args, "true")
					{{- else if eq $param.Type "time.Duration"}}
					args = append(args, "1s")
					{{- end}}
				{{- end}}
			{{- end}}
        {{- else }}
            // Add positional args
			{{- if eq .Type "string"}}
			args = append(args, "test")
			{{- else if eq .Type "int"}}
			args = append(args, "1")
            {{- else if eq .Type "bool"}}
            args = append(args, "true")
            {{- else if eq .Type "time.Duration"}}
            args = append(args, "1s")
            {{- end }}
        {{- end }}
    {{- end }}
    {{- end }}

	err := cmd.Execute(args)
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}
	if !called {
		t.Error("CommandAction was not called")
	}

    // Assertions
    {{- range $shortBools }}
        if cmd.{{.Name}} != true {
             t.Errorf("Expected {{.Name}} to be true")
        }
    {{- end }}
    {{- if $hasShortValFlag }}
        {{- if eq $shortValType "string" }}
        if cmd.{{$shortValFlag.Name}} != "test" {
             t.Errorf("Expected {{$shortValFlag.Name}} to be 'test'")
        }
        {{- else if eq $shortValType "int" }}
        if cmd.{{$shortValFlag.Name}} != 1 {
             t.Errorf("Expected {{$shortValFlag.Name}} to be 1")
        }
        {{- end }}
    {{- end }}
}
{{- end }}
