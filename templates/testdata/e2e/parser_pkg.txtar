-- input/go.mod --
module example.com/test

go 1.22
-- input/main.go --
package main

import (
	"example.com/pkg"
	"encoding/json"
)

// MyCmd is a subcommand `app mycmd`
//
// Flags:
//	myflag: --json-data (parser: "encoding/json".Unmarshal)
//	local_parser: (parser: LocalFunc)
//	gen_pkg: (generator: "example.com/pkg".Gen)
//	gen_local: (generator: Gen)
func MyCmd(
	myflag string,
	local_parser string,
	gen_pkg string,
	gen_local string,
) {}

func LocalFunc(s string) (string, error) { return s, nil }
func Gen() (string, error) { return "", nil }
-- tests.txt --
This is a full go e2e test

-- expected/cmd/errors.go --
// Code generated by github.com/arran4/go-subcommand/cmd/gosubc. DO NOT EDIT.

package cmd

import "errors"

// ErrPrintHelp when returned by any function anywhere it will switch the command from whatever it is to help.
var ErrPrintHelp = errors.New("print help")

// ErrHelp tells the user to use help.
var ErrHelp = errors.New("help requested")

// ErrExitCode Mostly used as a pass through, it's caught, but if the sub error is nil and it's not wrapped in another error, it counts as no error.
type ErrExitCode struct {
	Err  error
	Code int
}

func (e *ErrExitCode) Error() string {
	if e.Err == nil {
		return ""
	}
	return e.Err.Error()
}

func (e *ErrExitCode) Unwrap() error {
	return e.Err
}
-- expected/cmd/app/root_test.go --
// Code generated by github.com/arran4/go-subcommand/cmd/gosubc. DO NOT EDIT.

package main

import (
	"testing"
)

func TestRoot_Execute(t *testing.T) {
	cmd, err := NewRoot("test", "", "", "")
	if err != nil {
		t.Fatalf("Failed to create root command: %v", err)
	}

	// No function defined for root command, so Execute expects a subcommand.
	// We can test that it fails with unknown command or usage.
	err = cmd.Execute([]string{"unknown-command"})
	if err == nil {
		t.Error("Expected error for unknown command, got nil")
	}

}
-- expected/cmd/app/mycmd_test.go --
// Code generated by github.com/arran4/go-subcommand/cmd/gosubc. DO NOT EDIT.

package main

import (
	"flag"
	"testing"
)

func TestMycmd_Execute(t *testing.T) {

	parent := &RootCmd{
		FlagSet:  flag.NewFlagSet("root", flag.ContinueOnError),
		Commands: make(map[string]func() Cmd),
	}
	cmd := parent.NewMycmd()

	called := false
	cmd.CommandAction = func(c *Mycmd) error {
		called = true
		return nil
	}

	args := []string{}
	args = append(args, "--myflag")
	args = append(args, "test")
	args = append(args, "--local_parser")
	args = append(args, "test")
	args = append(args, "--gen_pkg")
	args = append(args, "test")
	args = append(args, "--gen_local")
	args = append(args, "test")

	err := cmd.Execute(args)
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}
	if !called {
		t.Error("CommandAction was not called")
	}

	if cmd.myflag != "test" {
		t.Errorf("Expected myflag to be 'test', got '%v'", cmd.myflag)
	}
	if cmd.local_parser != "test" {
		t.Errorf("Expected local_parser to be 'test', got '%v'", cmd.local_parser)
	}
	if cmd.gen_pkg != "test" {
		t.Errorf("Expected gen_pkg to be 'test', got '%v'", cmd.gen_pkg)
	}
	if cmd.gen_local != "test" {
		t.Errorf("Expected gen_local to be 'test', got '%v'", cmd.gen_local)
	}
}
-- expected/cmd/app/root.go --
// Code generated by github.com/arran4/go-subcommand/cmd/gosubc. DO NOT EDIT.

package main

import (
	"flag"
	"fmt"
	"io"
	"os"
	"slices"
	"strings"
	"sync"

	"example.com/test/cmd/app/templates"
)

type Cmd interface {
	Execute(args []string) error
	Usage()
}

type InternalCommand struct {
	Exec      func(args []string) error
	UsageFunc func()
}

func (c *InternalCommand) Execute(args []string) error {
	return c.Exec(args)
}

func (c *InternalCommand) Usage() {
	c.UsageFunc()
}

func NewLazyCommand(f func() Cmd) func() Cmd {
	var once sync.Once
	var cmd Cmd
	return func() Cmd {
		once.Do(func() {
			cmd = f()
		})
		return cmd
	}
}

type UserError struct {
	Err error
	Msg string
}

func (e *UserError) Error() string {
	if e.Err != nil {
		return fmt.Sprintf("%s: %v", e.Msg, e.Err)
	}
	return e.Msg
}

func NewUserError(err error, msg string) *UserError {
	return &UserError{Err: err, Msg: msg}
}

func executeUsage(out io.Writer, templateName string, data any) error {
	return templates.GetTemplates().ExecuteTemplate(out, templateName, data)
}

type RootCmd struct {
	*flag.FlagSet
	Commands      map[string]func() Cmd
	Version       string
	Commit        string
	Date          string
	CommandAction func(c *RootCmd) error
}

type UsageDataRootCmd struct {
	*RootCmd
	Recursive bool
}

func (c *RootCmd) Usage() {
	err := executeUsage(os.Stderr, "app_usage.txt", UsageDataRootCmd{c, false})
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error generating usage: %s\n", err)
	}
}

func (c *RootCmd) UsageRecursive() {
	err := executeUsage(os.Stderr, "app_usage.txt", UsageDataRootCmd{c, true})
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error generating usage: %s\n", err)
	}
}

func NewRoot(name, version, commit, date string) (*RootCmd, error) {
	c := &RootCmd{
		FlagSet:  flag.NewFlagSet(name, flag.ExitOnError),
		Commands: make(map[string]func() Cmd),
		Version:  version,
		Commit:   commit,
		Date:     date,
	}
	c.FlagSet.Usage = c.Usage

	{
		subCmd := NewLazyCommand(func() Cmd { return c.NewMycmd() })
		c.Commands["mycmd"] = subCmd
	}
	c.Commands["help"] = func() Cmd {
		return &InternalCommand{
			Exec: func(args []string) error {
				if slices.Contains(args, "-deep") {
					c.UsageRecursive()
					return nil
				}
				c.Usage()
				return nil
			},
			UsageFunc: c.Usage,
		}
	}
	c.Commands["usage"] = func() Cmd {
		return &InternalCommand{
			Exec: func(args []string) error {
				if slices.Contains(args, "-deep") {
					c.UsageRecursive()
					return nil
				}
				c.Usage()
				return nil
			},
			UsageFunc: c.Usage,
		}
	}
	c.Commands["version"] = func() Cmd {
		return &InternalCommand{
			Exec: func(args []string) error {
				fmt.Printf("Version: %s\nCommit: %s\nDate: %s\n", c.Version, c.Commit, c.Date)
				return nil
			},
			UsageFunc: func() {
				fmt.Fprintf(os.Stderr, "Usage: %s version\n", os.Args[0])
			},
		}
	}
	return c, nil
}

func (c *RootCmd) Execute(args []string) error {
	var remainingArgs []string
	for i := 0; i < len(args); i++ {
		arg := args[i]
		if arg == "--" {
			remainingArgs = append(remainingArgs, args[i+1:]...)
			break
		}
		if strings.HasPrefix(arg, "--") {
			if arg == "--help" {
				c.Usage()
				return nil
			}
			name := arg[2:]
			value := ""
			hasValue := false
			if strings.Contains(name, "=") {
				parts := strings.SplitN(name, "=", 2)
				name = parts[0]
				value = parts[1]
				hasValue = true
			}
			_ = value
			_ = hasValue
			switch name {
			default:
				return fmt.Errorf("unknown flag: --%s", name)
			}
		} else if strings.HasPrefix(arg, "-") && arg != "-" {
			// Short flags
			shorts := arg[1:]
			for j := 0; j < len(shorts); j++ {
				char := string(shorts[j])
				if char == "h" {
					c.Usage()
					return nil
				}
				found := false
				if !found {
					return fmt.Errorf("unknown flag: -%s", char)
				}
			}
		} else {
			remainingArgs = append(remainingArgs, args[i:]...)
			break
		}
	}

	if len(remainingArgs) > 0 {
		if cmd, ok := c.Commands[remainingArgs[0]]; ok {
			return cmd().Execute(remainingArgs[1:])
		}
	}
	c.Usage()
	if len(remainingArgs) > 0 {
		return fmt.Errorf("unknown command: %s", remainingArgs[0])
	}
	return nil
}
-- expected/cmd/app/templates/templates.go --
// Code generated by github.com/arran4/go-subcommand/cmd/gosubc. DO NOT EDIT.

package templates

import (
	"embed"
	"sync"
	"text/template"
)

// CLITemplatesFS contains all CLI usage templates.
//
//go:embed *.txt
var CLITemplatesFS embed.FS

var (
	compiledTemplates *template.Template
	templatesOnce     sync.Once
)

func GetTemplates() *template.Template {
	templatesOnce.Do(func() {
		compiledTemplates = template.Must(template.New("").ParseFS(CLITemplatesFS, "*.txt"))
	})
	return compiledTemplates
}
-- expected/cmd/app/templates/app_usage.txt --
{{/* Do not modify: Generated by github.com/arran4/go-subcommand/cmd/gosubc */ -}}
Usage: app
-- expected/cmd/app/templates/mycmd_usage.txt --
{{/* Do not modify: Generated by github.com/arran4/go-subcommand/cmd/gosubc */ -}}
Usage: app mycmd [flags...]

Subcommands:
    help         Print this help message
    usage        Print this usage message



Flags:
    --json-data string
    --local_parser string
    --gen_pkg string
    --gen_local string
-- expected/cmd/app/flag_helpers.go --
// Code generated by github.com/arran4/go-subcommand/cmd/gosubc. DO NOT EDIT.

package main

import (
	"fmt"
	"strconv"
	"strings"
	"time"
)

type StringSlice []string

func (s *StringSlice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("[%s]", strings.Join(*s, ", "))
}

func (s *StringSlice) Set(value string) error {
	*s = append(*s, value)
	return nil
}

type IntSlice []int

func (s *IntSlice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *IntSlice) Set(value string) error {
	i, err := strconv.Atoi(value)
	if err != nil {
		return err
	}
	*s = append(*s, i)
	return nil
}

type Int64Slice []int64

func (s *Int64Slice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *Int64Slice) Set(value string) error {
	i, err := strconv.ParseInt(value, 10, 64)
	if err != nil {
		return err
	}
	*s = append(*s, i)
	return nil
}

type Int32Slice []int32

func (s *Int32Slice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *Int32Slice) Set(value string) error {
	i, err := strconv.ParseInt(value, 10, 32)
	if err != nil {
		return err
	}
	*s = append(*s, int32(i))
	return nil
}

type Int16Slice []int16

func (s *Int16Slice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *Int16Slice) Set(value string) error {
	i, err := strconv.ParseInt(value, 10, 16)
	if err != nil {
		return err
	}
	*s = append(*s, int16(i))
	return nil
}

type Int8Slice []int8

func (s *Int8Slice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *Int8Slice) Set(value string) error {
	i, err := strconv.ParseInt(value, 10, 8)
	if err != nil {
		return err
	}
	*s = append(*s, int8(i))
	return nil
}

type UintSlice []uint

func (s *UintSlice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *UintSlice) Set(value string) error {
	i, err := strconv.ParseUint(value, 10, 64) // uint can be 32 or 64 bit, but 64 covers both
	if err != nil {
		return err
	}
	*s = append(*s, uint(i))
	return nil
}

type Uint64Slice []uint64

func (s *Uint64Slice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *Uint64Slice) Set(value string) error {
	i, err := strconv.ParseUint(value, 10, 64)
	if err != nil {
		return err
	}
	*s = append(*s, i)
	return nil
}

type Uint32Slice []uint32

func (s *Uint32Slice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *Uint32Slice) Set(value string) error {
	i, err := strconv.ParseUint(value, 10, 32)
	if err != nil {
		return err
	}
	*s = append(*s, uint32(i))
	return nil
}

type Uint16Slice []uint16

func (s *Uint16Slice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *Uint16Slice) Set(value string) error {
	i, err := strconv.ParseUint(value, 10, 16)
	if err != nil {
		return err
	}
	*s = append(*s, uint16(i))
	return nil
}

type Uint8Slice []uint8

func (s *Uint8Slice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *Uint8Slice) Set(value string) error {
	i, err := strconv.ParseUint(value, 10, 8)
	if err != nil {
		return err
	}
	*s = append(*s, uint8(i))
	return nil
}

type Float64Slice []float64

func (s *Float64Slice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *Float64Slice) Set(value string) error {
	f, err := strconv.ParseFloat(value, 64)
	if err != nil {
		return err
	}
	*s = append(*s, f)
	return nil
}

type Float32Slice []float32

func (s *Float32Slice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *Float32Slice) Set(value string) error {
	f, err := strconv.ParseFloat(value, 32)
	if err != nil {
		return err
	}
	*s = append(*s, float32(f))
	return nil
}

type BoolSlice []bool

func (s *BoolSlice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *BoolSlice) Set(value string) error {
	b, err := strconv.ParseBool(value)
	if err != nil {
		return err
	}
	*s = append(*s, b)
	return nil
}

func (s *BoolSlice) IsBoolFlag() bool {
	return true
}

type DurationSlice []time.Duration

func (s *DurationSlice) String() string {
	if s == nil {
		return "[]"
	}
	return fmt.Sprintf("%v", *s)
}

func (s *DurationSlice) Set(value string) error {
	d, err := time.ParseDuration(value)
	if err != nil {
		return err
	}
	*s = append(*s, d)
	return nil
}

type StringPointerSlice []*string

func (s *StringPointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, *p)
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *StringPointerSlice) Set(value string) error {
	val := value
	*s = append(*s, &val)
	return nil
}

type IntPointerSlice []*int

func (s *IntPointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%d", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *IntPointerSlice) Set(value string) error {
	i, err := strconv.Atoi(value)
	if err != nil {
		return err
	}
	*s = append(*s, &i)
	return nil
}

type Int64PointerSlice []*int64

func (s *Int64PointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%d", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *Int64PointerSlice) Set(value string) error {
	i, err := strconv.ParseInt(value, 10, 64)
	if err != nil {
		return err
	}
	*s = append(*s, &i)
	return nil
}

type Int32PointerSlice []*int32

func (s *Int32PointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%d", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *Int32PointerSlice) Set(value string) error {
	i, err := strconv.ParseInt(value, 10, 32)
	if err != nil {
		return err
	}
	v := int32(i)
	*s = append(*s, &v)
	return nil
}

type Int16PointerSlice []*int16

func (s *Int16PointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%d", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *Int16PointerSlice) Set(value string) error {
	i, err := strconv.ParseInt(value, 10, 16)
	if err != nil {
		return err
	}
	v := int16(i)
	*s = append(*s, &v)
	return nil
}

type Int8PointerSlice []*int8

func (s *Int8PointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%d", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *Int8PointerSlice) Set(value string) error {
	i, err := strconv.ParseInt(value, 10, 8)
	if err != nil {
		return err
	}
	v := int8(i)
	*s = append(*s, &v)
	return nil
}

type UintPointerSlice []*uint

func (s *UintPointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%d", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *UintPointerSlice) Set(value string) error {
	i, err := strconv.ParseUint(value, 10, 64)
	if err != nil {
		return err
	}
	v := uint(i)
	*s = append(*s, &v)
	return nil
}

type Uint64PointerSlice []*uint64

func (s *Uint64PointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%d", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *Uint64PointerSlice) Set(value string) error {
	i, err := strconv.ParseUint(value, 10, 64)
	if err != nil {
		return err
	}
	*s = append(*s, &i)
	return nil
}

type Uint32PointerSlice []*uint32

func (s *Uint32PointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%d", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *Uint32PointerSlice) Set(value string) error {
	i, err := strconv.ParseUint(value, 10, 32)
	if err != nil {
		return err
	}
	v := uint32(i)
	*s = append(*s, &v)
	return nil
}

type Uint16PointerSlice []*uint16

func (s *Uint16PointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%d", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *Uint16PointerSlice) Set(value string) error {
	i, err := strconv.ParseUint(value, 10, 16)
	if err != nil {
		return err
	}
	v := uint16(i)
	*s = append(*s, &v)
	return nil
}

type Uint8PointerSlice []*uint8

func (s *Uint8PointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%d", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *Uint8PointerSlice) Set(value string) error {
	i, err := strconv.ParseUint(value, 10, 8)
	if err != nil {
		return err
	}
	v := uint8(i)
	*s = append(*s, &v)
	return nil
}

type Float64PointerSlice []*float64

func (s *Float64PointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%v", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *Float64PointerSlice) Set(value string) error {
	f, err := strconv.ParseFloat(value, 64)
	if err != nil {
		return err
	}
	*s = append(*s, &f)
	return nil
}

type Float32PointerSlice []*float32

func (s *Float32PointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%v", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *Float32PointerSlice) Set(value string) error {
	f, err := strconv.ParseFloat(value, 32)
	if err != nil {
		return err
	}
	v := float32(f)
	*s = append(*s, &v)
	return nil
}

type BoolPointerSlice []*bool

func (s *BoolPointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%v", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *BoolPointerSlice) Set(value string) error {
	b, err := strconv.ParseBool(value)
	if err != nil {
		return err
	}
	*s = append(*s, &b)
	return nil
}

func (s *BoolPointerSlice) IsBoolFlag() bool {
	return true
}

type DurationPointerSlice []*time.Duration

func (s *DurationPointerSlice) String() string {
	if s == nil {
		return "[]"
	}
	var parts []string
	for _, p := range *s {
		if p != nil {
			parts = append(parts, fmt.Sprintf("%v", *p))
		} else {
			parts = append(parts, "<nil>")
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}

func (s *DurationPointerSlice) Set(value string) error {
	d, err := time.ParseDuration(value)
	if err != nil {
		return err
	}
	*s = append(*s, &d)
	return nil
}
-- expected/cmd/agents.md --
<!-- Code generated by github.com/arran4/go-subcommand/cmd/gosubc. DO NOT EDIT. -->
All code under /cmd is generated code, do not place files here.

# Go Subcommand Information

Go Subcommand (`gosubc`) generates subcommand code for command-line interfaces (CLIs) in Go from source code comments.

## Key Features

- **Convention over Configuration:** Define your CLI structure with simple, intuitive code comments.
- **Zero Dependencies:** The generated code is self-contained and doesn't require any external libraries.
- **Automatic Code Generation:** `gosubc` parses your Go files and generates a complete, ready-to-use CLI.

## Installation

`gosubc` is a standalone tool and should not be added as a dependency in your `go.mod`. Install it using:

```bash
go install github.com/arran4/go-subcommand/cmd/gosubc@latest
```

## How it works

1.  **Define Your Commands**: Create a Go file and define a function that will serve as your command. Add a comment above the function.
2.  **Generate**: Run `gosubc generate` (or via `go generate`).
3.  **Result**: `gosubc` creates a `cmd/<app-name>` directory containing the generated CLI code.

## Comment Syntax

### Command Definition

```go
// FuncName is a subcommand 'root-cmd parent child'
func FuncName() {}
```

### Flags

Use a `Flags:` block or inline comments. Adhere to Go formatting.

```go
// FuncName is a subcommand 'root-cmd parent child'
//
// Flags:
//
//	username:  --username -u (default: "guest") The user to greet
//	count:     --count -c    (default: 1)       Number of times
func FuncName(username string, count int) {}
```

### Positional Arguments

Map positional arguments using `@N`.

```go
// Greet is a subcommand 'app greet'
//
// Flags:
//
//	name: @1 The name to greet
func Greet(name string) {}
```

### Variadic Arguments

Map remaining arguments using `...`.

```go
// Process is a subcommand 'app process'
//
// Flags:
//
//	files: ... List of files
func Process(files ...string) {}
```

## Important Note

Do not edit files in this directory directly if you can avoid it. They are overwritten on every generation. Modify the source code comments instead.
-- expected/cmd/app/mycmd.go --
// Code generated by github.com/arran4/go-subcommand/cmd/gosubc. DO NOT EDIT.

package main

import (
	"flag"
	"fmt"
	"os"
	"slices"
	"strings"

	"encoding/json"
	"example.com/pkg"

	"example.com/test"
)

var _ Cmd = (*Mycmd)(nil)

type Mycmd struct {
	*RootCmd
	Flags         *flag.FlagSet
	myflag        string
	local_parser  string
	gen_pkg       string
	gen_local     string
	SubCommands   map[string]func() Cmd
	CommandAction func(c *Mycmd) error
}

type UsageDataMycmd struct {
	*Mycmd
	Recursive bool
}

func (c *Mycmd) Usage() {
	err := executeUsage(os.Stderr, "mycmd_usage.txt", UsageDataMycmd{c, false})
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error generating usage: %s\n", err)
	}
}

func (c *Mycmd) UsageRecursive() {
	err := executeUsage(os.Stderr, "mycmd_usage.txt", UsageDataMycmd{c, true})
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error generating usage: %s\n", err)
	}
}

func (c *Mycmd) Execute(args []string) error {
	var remainingArgs []string
	for i := 0; i < len(args); i++ {
		arg := args[i]
		if arg == "--" {
			remainingArgs = append(remainingArgs, args[i+1:]...)
			break
		}
		if strings.HasPrefix(arg, "--") {
			if arg == "--help" {
				c.Usage()
				return nil
			}
			name := arg[2:]
			value := ""
			hasValue := false
			if strings.Contains(name, "=") {
				parts := strings.SplitN(name, "=", 2)
				name = parts[0]
				value = parts[1]
				hasValue = true
			}
			_ = value
			_ = hasValue
			switch name {

			case "myflag", "json-data":
				if !hasValue {
					if i+1 < len(args) {
						value = args[i+1]
						i++
					} else {
						return fmt.Errorf("flag %s requires a value", name)
					}
				}
				v, err := json.Unmarshal(value)
				if err != nil {
					return fmt.Errorf("invalid value for flag %s: %w", name, err)
				}
				c.myflag = v

			case "local_parser":
				if !hasValue {
					if i+1 < len(args) {
						value = args[i+1]
						i++
					} else {
						return fmt.Errorf("flag %s requires a value", name)
					}
				}
				v, err := LocalFunc(value)
				if err != nil {
					return fmt.Errorf("invalid value for flag %s: %w", name, err)
				}
				c.local_parser = v
			default:
				return fmt.Errorf("unknown flag: --%s", name)
			}
		} else if strings.HasPrefix(arg, "-") && arg != "-" {
			// Short flags
			shorts := arg[1:]
			for j := 0; j < len(shorts); j++ {
				char := string(shorts[j])
				if char == "h" {
					c.Usage()
					return nil
				}
				found := false

				if !found {
					return fmt.Errorf("unknown flag: -%s", char)
				}
			}
		} else {
			remainingArgs = append(remainingArgs, args[i:]...)
			break
		}
	}

	if len(remainingArgs) > 0 {
		if cmd, ok := c.SubCommands[remainingArgs[0]]; ok {
			return cmd().Execute(remainingArgs[1:])
		}
	}

	if c.CommandAction != nil {
		if err := c.CommandAction(c); err != nil {
			return fmt.Errorf("mycmd failed: %w", err)
		}
	} else {
		c.Usage()
	}

	return nil
}

func (c *RootCmd) NewMycmd() *Mycmd {
	set := flag.NewFlagSet("mycmd", flag.ContinueOnError)
	v := &Mycmd{
		RootCmd:     c,
		Flags:       set,
		SubCommands: make(map[string]func() Cmd),
	}

	set.Func("json-data", "TODO: Add usage text", func(s string) error {
		v, err := json.Unmarshal(s)
		if err != nil {
			return err
		}
		val := v
		v.myflag = val
		return nil
	})

	set.Func("local_parser", "TODO: Add usage text", func(s string) error {
		v, err := LocalFunc(s)
		if err != nil {
			return err
		}
		val := v
		v.local_parser = val
		return nil
	})
	set.Usage = v.Usage

	v.CommandAction = func(c *Mycmd) error {
		{
			var err error
			c.gen_pkg, err = pkg.Gen()
			if err != nil {
				return fmt.Errorf("failed to generate gen_pkg: %w", err)
			}
		}
		{
			var err error
			c.gen_local, err = Gen()
			if err != nil {
				return fmt.Errorf("failed to generate gen_local: %w", err)
			}
		}

		MyCmd(c.myflag, c.local_parser, c.gen_pkg, c.gen_local)
		return nil
	}

	v.SubCommands["help"] = func() Cmd {
		return &InternalCommand{
			Exec: func(args []string) error {
				if slices.Contains(args, "-deep") {
					v.UsageRecursive()
					return nil
				}
				v.Usage()
				return nil
			},
			UsageFunc: v.Usage,
		}
	}
	v.SubCommands["usage"] = func() Cmd {
		return &InternalCommand{
			Exec: func(args []string) error {
				if slices.Contains(args, "-deep") {
					v.UsageRecursive()
					return nil
				}
				v.Usage()
				return nil
			},
			UsageFunc: v.Usage,
		}
	}
	return v
}
-- expected/cmd/app/main.go --
// Code generated by github.com/arran4/go-subcommand/cmd/gosubc. DO NOT EDIT.

package main

//go:generate sh -c "command -v gosubc >/dev/null 2>&1 && gosubc generate || go run github.com/arran4/go-subcommand/cmd/gosubc generate"

import (
	"fmt"
	"os"

	"example.com/test/cmd"
)

var (
	version = "dev"
	commit  = "none"
	date    = "unknown"
)

func main() {
	root, err := NewRoot("app", version, commit, date)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	if err := root.Execute(os.Args[1:]); err != nil {
		if e, ok := err.(*cmd.ErrExitCode); ok {
			if e.Err != nil {
				fmt.Fprintf(os.Stderr, "Error: %v\n", e.Err)
			}
			os.Exit(e.Code)
		}
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}
