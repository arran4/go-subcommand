[{"id":0,"href":"/go-subcommand/docs/reference/cli-reference/","title":"CLI Reference","section":"Reference","content":"CLI Reference# The gosubc tool has the following commands:\ngenerate# Generates the Go code for your CLI.\ngosubc generate [flags]Flags:\n--dir \u0026lt;path\u0026gt;: The project root directory containing go.mod. Defaults to .. --man-dir \u0026lt;path\u0026gt;: Directory to generate Unix man pages in. If omitted, no man pages are generated. list# Lists all identified subcommands in the project. Useful for debugging parsing.\ngosubc list [flags]Flags:\n--dir \u0026lt;path\u0026gt;: The project root directory. validate# Validates subcommand definitions for conflicts or errors.\ngosubc validate [flags]Flags:\n--dir \u0026lt;path\u0026gt;: The project root directory. "},{"id":1,"href":"/go-subcommand/docs/usage/getting-started/","title":"Getting Started","section":"Usage","content":"Getting Started# Let\u0026rsquo;s build a simple CLI application named greet.\n1. Create a Go Module# mkdir greet cd greet go mod init example.com/greet2. Define a Command# Create main.go and define your command function.\npackage main import \u0026#34;fmt\u0026#34; // Hello is a subcommand `greet hello` // Prints a greeting. func Hello(name string) { fmt.Printf(\u0026#34;Hello, %s!\\n\u0026#34;, name) } func main() { // This will be replaced by the generated code usage, // but for now you can leave it empty or use it to run the generated cmd. }3. Configure Generation# Create a generate.go file to instruct go generate.\npackage main //go:generate gosubc generate4. Generate Code# Run the generator:\ngo generateThis will create a cmd/greet directory with the generated code.\n5. Run Your CLI# You can now run your CLI using go run:\ngo run ./cmd/greet hello --name WorldOutput:\nHello, World!"},{"id":2,"href":"/go-subcommand/docs/introduction/","title":"Introduction","section":"Docs","content":"Introduction# Go Subcommand is a powerful, dependency-less library and tool for generating subcommand-based command-line interfaces (CLIs) in Go. It leverages convention over configuration by parsing your Go code comments to define the CLI structure, flags, and parameters.\nWhy Go Subcommand?# Zero Dependencies: The generated code depends only on the Go standard library. Intuitive: Define your CLI structure naturally using Go functions and comments. Automated: Focus on your logic; let gosubc handle the boilerplate. Type Safe: Automatically handles type conversions for int, bool, time.Duration, and more. Feature Rich: Supports nested subcommands, aliases, default values, variadic arguments, and man page generation. Key Features# Subcommand Trees: Create deep hierarchies of commands (e.g., app users create). Argument Mapping: Maps function parameters to CLI flags and positional arguments. Flexible Comments: Define flags and descriptions directly in your Go source code. Generators: CLI Code: Fully functional CLI entry points. Man Pages: Unix manual pages for your tool. Usage: Automatic usage text generation. Status# Pre-v1. The API and generated code structure may change. However, it is stable enough for use in production tools, including its own CLI.\n"},{"id":3,"href":"/go-subcommand/docs/usage/defining-commands/","title":"Defining Commands","section":"Usage","content":"Defining Commands# Commands are defined by adding specific comments to your Go functions.\nSyntax# // FunctionName is a subcommand `root-cmd sub-cmd...` // Description text... FunctionName: The name of the Go function to execute. root-cmd: The name of your root application (e.g., git, kubectl). sub-cmd\u0026hellip;: A space-separated list of subcommands (e.g., remote add). Description# The text following the command definition or on subsequent lines is used as the command description in usage text.\n// Push is a subcommand `git push` // Update remote refs along with associated objects. func Push() { ... }Extended Help# Any comments that are not part of the command definition or parameter documentation are treated as Extended Help. This text is shown when the user requests help for a specific command (e.g., via man pages or detailed help output).\nNested Commands# You can create deep hierarchies.\n// UserCreate is a subcommand `app users create` func UserCreate() {} // UserDelete is a subcommand `app users delete` func UserDelete() {}Intermediate commands (e.g., users in app users create) do not need to be explicitly defined if they don\u0026rsquo;t have specific logic. gosubc will create \u0026ldquo;synthetic\u0026rdquo; commands for them. However, if you want to define behavior for the parent command, you can:\n// Users is a subcommand `app users` func Users() { fmt.Println(\u0026#34;Manage users\u0026#34;) }"},{"id":4,"href":"/go-subcommand/docs/introduction/installation/","title":"Installation","section":"Introduction","content":"Installation# To use Go Subcommand, you need to install the gosubc CLI tool.\nPrerequisites# Go: Version 1.18 or later. Installing gosubc# Run the following command to install the latest version:\ngo install github.com/arran4/go-subcommand/cmd/gosubc@latestVerify the installation:\ngosubc --helpAdding to Your Project# You don\u0026rsquo;t need to import go-subcommand in your application logic files unless you are using specific helper types. The generated code will reside in a separate package (usually cmd/appname).\n"},{"id":5,"href":"/go-subcommand/docs/usage/flags-parameters/","title":"Flags \u0026 Parameters","section":"Usage","content":"Flags \u0026amp; Parameters# go-subcommand automatically maps your function parameters to command-line flags and arguments.\nAutomatic Mapping# Function parameters are converted to flags by default.\nfunc Server(port int, verbose bool)Generates flags:\n--port \u0026lt;int\u0026gt; --verbose (boolean flag) Flag names are automatically converted to kebab-case (e.g., maxRetries -\u0026gt; --max-retries).\nCustomizing Flags# You can customize flags using comments. There are three ways to define them, in order of priority:\nFlags Block: A Flags: block in the function documentation. Inline Comment: Comment on the same line as the parameter. Preceding Comment: Comment on the line before the parameter. 1. Flags Block (Highest Priority)# // MyCmd is a subcommand `app cmd` // Flags: // port: default: 8080 description: Port to listen on func MyCmd(port int) {}2. Inline Comment# func MyCmd( port int, // default: 8080 description: Port to listen on ) {}3. Preceding Comment# // default: 8080 description: Port to listen on port intSyntax Reference# The parameter definition syntax supports several attributes:\nFlag Alias: flag: -p or just -p to define aliases. Description: description: text or just text (if unambiguous). Default Value: default: value. Positional Argument: @N (e.g., @1) marks the parameter as a positional argument at index N (1-based). Variadic: ... or min...max (e.g., 1... or 1...3) for variadic arguments. Examples# Positional Argument\n// Copy is a subcommand `cp` func Copy( src string, // @1 source file dst string, // @2 destination file )Custom Flag Name\nfunc Serve( addr string, // flag: --address -a description: Bind address )Required Variadic Arguments\nfunc Echo( args []string, // @1 ... description: Strings to echo )Supported Types# int, int64, etc. bool string time.Duration (e.g., 10s, 1m) float64 Structs (via custom selector handling, advanced) Implicit Parameters# You can also define parameters solely in comments without them strictly matching the function signature\u0026rsquo;s parameter names if using advanced usage, but typically they map 1:1 to function arguments.\n"},{"id":6,"href":"/go-subcommand/docs/usage/","title":"Usage","section":"Docs","content":"Usage# This section covers how to use go-subcommand to generate your CLI.\n"},{"id":7,"href":"/go-subcommand/docs/reference/","title":"Reference","section":"Docs","content":"Reference# Detailed reference documentation for go-subcommand.\n"},{"id":8,"href":"/go-subcommand/docs/advanced/","title":"Advanced","section":"Docs","content":"Advanced Topics# Man Page Generation# go-subcommand can generate standard Unix man pages.\ngosubc generate --man-dir ./manThis creates a man1 directory inside ./man containing gzipped man pages (e.g., my-app.1.gz, my-app-subcmd.1.gz).\nThe content is derived from:\nThe command description. The extended help text in comments. Flag descriptions and defaults. Architecture# The generator works by:\nParsing: It scans .go files in your module (using go/parser and go/ast) to find functions with the magic // ... is a subcommand ... comment. Modeling: It builds a tree of commands, handling implicit parent commands and resolving parameter details. Generating: It uses Go templates (embedded in the tool) to generate: root.go: The entry point and root command logic. cmd.go: Helper interfaces and shared logic. Subcommand files: subcommand_xyz.go for each command node. Usage templates: Text files for usage output. Runtime Logic# The generated code uses a lightweight Command interface.\nFlags: It uses the standard flag package. Dispatch: Commands are organized in a map/tree structure. Execute methods dispatch to subcommands or run the bound function. Dependency-Free: The output does not import github.com/arran4/go-subcommand at runtime. Conditional Generation# To ensure your project builds even if a contributor doesn\u0026rsquo;t have gosubc installed, use this go:generate directive:\n//go:generate sh -c \u0026#34;command -v gosubc \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026amp; gosubc generate || go run github.com/arran4/go-subcommand/cmd/gosubc generate\u0026#34;This attempts to use the installed binary first, falling back to go run (which compiles it from source) if missing.\n"}]